import { z } from "zod/v4";

import type { BlockResponse } from "./block";

import {
  AuthRequirement,
  Credentials,
  Parameter,
  ParameterType,
} from "./models";
import { registry } from "./registry";

/**
 * Extra context passed to tool handlers
 */
export type RequestHandlerExtra = {
  /** Authentication data if provided */
  auth?: {
    credentials: Credentials;
    provider: string;
  };
  /** Execution mode: 'headless' for non-interactive, 'interactive' for user interaction (defaults to 'headless') */
  mode: "headless" | "interactive";
};

type ToolOptions<
  TSchema extends Record<string, z.ZodTypeAny>,
  TType extends "block" | "json" = "json",
> = {
  authRequirements?: {
    provider: string;
    required?: boolean;
    scopeBundle: string;
  };
  description: string;
  inputSchema: TSchema;
  type?: TType;
};

/**
 * Register a function as an Opal tool
 *
 * @example
 * ```typescript
 * const greetTool = registerTool('greet', {
 *   description: 'Greet a user',
 *   inputSchema: {
 *     name: z.string().describe('The name to greet')
 *   }
 * }, async (params) => {
 *   // params is automatically typed as { name: string }
 *   return `Hello, ${params.name}!`;
 * });
 * ```
 *
 * @example
 * ```typescript
 * // With auth and execution mode
 * const fetchTool = registerTool('fetch_data', {
 *   description: 'Fetch data from API',
 *   inputSchema: {
 *     url: z.string().describe('URL to fetch')
 *   },
 *   authRequirements: {
 *     provider: 'api-service',
 *     scopeBundle: 'read'
 *   }
 * }, async (params, extra) => {
 *   // extra.mode: 'headless' | 'interactive'
 *   // extra.auth: { provider, credentials }
 *   const headers = extra?.auth ? { Authorization: extra.auth.credentials.token } : {};
 *   return fetch(params.url, { headers });
 * });
 * ```
 */
// Overload for block tools
export function registerTool<TSchema extends Record<string, z.ZodTypeAny>>(
  name: string,
  options: ToolOptions<TSchema, "block">,
  handler: (
    params: { [K in keyof TSchema]: z.infer<TSchema[K]> },
    extra?: RequestHandlerExtra,
  ) => BlockResponse | Promise<BlockResponse>,
): typeof handler;
// Overload for JSON tools (or when type is omitted)
export function registerTool<TSchema extends Record<string, z.ZodTypeAny>>(
  name: string,
  options: Omit<ToolOptions<TSchema>, "type"> | ToolOptions<TSchema, "json">,
  handler: (
    params: { [K in keyof TSchema]: z.infer<TSchema[K]> },
    extra?: RequestHandlerExtra,
  ) => Promise<unknown> | unknown,
): typeof handler;
// Implementation
export function registerTool<TSchema extends Record<string, z.ZodTypeAny>>(
  name: string,
  options: ToolOptions<TSchema, "block" | "json">,
  handler: (
    params: { [K in keyof TSchema]: z.infer<TSchema[K]> },
    extra?: RequestHandlerExtra,
  ) => Promise<unknown> | unknown,
): typeof handler {
  // Register the tool with all services
  const responseType = options.type || "json";
  for (const service of registry.services) {
    service.registerTool(
      name,
      options.description,
      handler,
      jsonSchemaToParameters(z.toJSONSchema(z.object(options.inputSchema))),
      `/tools/${name.replace(/_/g, "-")}`,
      options.authRequirements
        ? [
            new AuthRequirement(
              options.authRequirements.provider,
              options.authRequirements.scopeBundle,
              options.authRequirements.required ?? true,
            ),
          ]
        : undefined,
      responseType,
      true,
    );
  }

  return handler;
}

/**
 * Convert JSON Schema to Parameter definitions
 * This converts the output of z.toJSONSchema() back to the Parameter[] format
 * expected by the legacy discovery endpoint
 */
function jsonSchemaToParameters(jsonSchema: {
  properties?: Record<string, unknown>;
  required?: string[];
}): Parameter[] {
  const parameters: Parameter[] = [];

  if (!jsonSchema.properties) {
    return parameters;
  }

  const required = jsonSchema.required || [];

  for (const [key, value] of Object.entries(jsonSchema.properties)) {
    const prop = value as { description?: string; type?: string };
    parameters.push(
      new Parameter(
        key,
        jsonSchemaTypeToParameterType(prop.type || "string"),
        prop.description || "",
        required.includes(key),
      ),
    );
  }

  return parameters;
}

/**
 * Map JSON Schema type to ParameterType
 */
function jsonSchemaTypeToParameterType(jsonType: string): ParameterType {
  switch (jsonType) {
    case "array":
      return ParameterType.List;
    case "boolean":
      return ParameterType.Boolean;
    case "integer":
      return ParameterType.Integer;
    case "number":
      return ParameterType.Number;
    case "object":
      return ParameterType.Dictionary;
    case "string":
      return ParameterType.String;
    default:
      return ParameterType.String;
  }
}
